<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trou Noir Spirale Dynamique</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background-color: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 2px solid #fff;
            border-radius: 8px;
            cursor: pointer;
            z-index: 10;
        }
        button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>
<button id="startButton">Démarrer le Trou Noir</button>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height, centerX, centerY;
    let lines = [];
    let mouseX, mouseY;
    let requestId;
    let running = false;

    function resizeCanvas() {
        width = window.innerWidth;
        height = window.innerHeight;
        centerX = width / 2;
        centerY = height / 2;
        canvas.width = width;
        canvas.height = height;
    }

    // Fonction pour générer des lignes aléatoires
    function generateLine() {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 300 + 100; // Distance plus grande pour simuler le trou noir
        const length = Math.random() * 100 + 50;

        lines.push({
            x1: centerX + Math.cos(angle) * distance,
            y1: centerY + Math.sin(angle) * distance,
            x2: centerX + Math.cos(angle) * (distance + length),
            y2: centerY + Math.sin(angle) * (distance + length),
            speed: Math.random() * 1.5 + 0.5,
            curvature: Math.random() * 0.03 + 0.01, // Courbure accrue pour un effet de spirale
            angle: angle,
            distance: distance,
            rotationSpeed: Math.random() * 0.05 + 0.008, // Vitesse de rotation en spirale
            opacity: 1, // Opacité initiale
            hue: Math.random() * 360,
            width: Math.random() * 4 + 1
        });
    }

    // Fonction principale pour dessiner les lignes
    function draw() {
        ctx.clearRect(0, 0, width, height);

        lines.forEach((line, index) => {
            ctx.strokeStyle = `hsla(${line.hue}, 100%, 50%, ${line.opacity})`; // Transparence progressive
            ctx.lineWidth = line.width;
            ctx.beginPath();
            ctx.moveTo(line.x1, line.y1);
            ctx.lineTo(line.x2, line.y2);
            ctx.stroke();

            // Effet de spirale en fonction de la distance du centre
            line.angle += line.rotationSpeed;
            line.distance *= 0.99; // Les lignes sont progressivement "aspirées"
            line.opacity -= 0.01;  // Diminution de l'opacité avec la distance
            line.x1 = centerX + Math.cos(line.angle) * line.distance;
            line.y1 = centerY + Math.sin(line.angle) * line.distance;
            line.x2 = centerX + Math.cos(line.angle) * (line.distance + 50);
            line.y2 = centerY + Math.sin(line.angle) * (line.distance + 50);

            // Vérifier si la ligne est "aspirée" complètement
            if (line.distance < 50 || line.opacity <= 0) {
                lines.splice(index, 1);
            }
        });

        // Limiter le nombre de lignes pour éviter une surcharge
        if (lines.length < 800) {
            generateLine();
        }

        requestId = requestAnimationFrame(draw);
    }

    // Fonction pour démarrer l'animation
    function startAnimation() {
        if (!running) {
            running = true;
            lines = [];
            resizeCanvas();
            draw();
        }
    }

    // Gérer la redimension de la fenêtre
    window.addEventListener('resize', resizeCanvas);

    // Mise à jour des coordonnées de la souris
    window.addEventListener('mousemove', (event) => {
        mouseX = event.clientX;
        mouseY = event.clientY;
    });

    // Lancer l'animation lorsque le bouton est cliqué
    document.getElementById('startButton').addEventListener('click', () => {
        document.getElementById('startButton').style.display = 'none';
        startAnimation();
    });

    // Initialisation de la taille du canvas
    resizeCanvas();
</script>
</body>
</html>